image: "ghcr.io/opensovereigncloud/sgxdatacenterattestationprimitives/pccs"
version: "latest"
replicas: 3

# Always | IfNotPresent | Never
imagePullPolicy: Always 

imagePullSecrets:
  # Set to true to create an image pull secret automatically
  # using the credentials provided below.
  enabled: false
  data:
    # Docker registry username
    username: myuser
    # Docker registry password or personal access token
    password: teste
    # Email associated with the Docker registry account
    email: myuser@example.com
    # Docker registry URL
    registry: https://index.docker.io/v1/

# pod-level security settings to minimize security risks
podSecurityContext:
  # We run the container using the same user defined in the image.
  runAsUser: 65333
  fsGroup: 65333
  runAsNonRoot: true

# Topology Spread Constraints allow pods to be distributed across failure domains
# to improve resilience and high availability.
topologySpreadConstraints:
  # Enable or disable the application of topology spread constraints.
  enabled: true
  # The maximum skew allowed between the number of pods in different topology domains.
  maxSkew: 1
  # The topology key to use for spreading pods, e.g., zone, node, or hostname.
  topologyKey: "topology.kubernetes.io/zone"
  # What to do if the constraint cannot be satisfied:
  # "ScheduleAnyway" (soft) or "DoNotSchedule" (hard).
  whenUnsatisfiable: "ScheduleAnyway"

# Resource requests and limits for the container
resources:
  # Minimum guaranteed CPU and memory for the container
  requests:
    cpu: "500m"
    memory: "512Mi"
  # Maximum CPU and memory the container can consume
  limits:
    cpu: "1"
    memory: "1Gi"

# Startup probe checks if the application has successfully started
# Paths appear to vary based on the selected configuration (e.g., using v3 updates all paths accordingly).
# Making probe endpoints configurable would allow adjustments if they change due to configuration changes.
startupProbe:
  enabled: true
  path: "/health/startup"

# Liveness probe ensures the application is still running and responsive
livenessProbe:
  enabled: true
  path: "/health/live"

# Readiness probe ensures the service is ready to accept traffic
readinessProbe:
  enabled: true
  path: "/health/ready"

# PCCS Kubernetes service configuration
service:
  port: 8081

fluentbit:
  # Enable or disable the Fluent Bit sidecar container
  enabled: true

  # Fluent Bit container image (kept in the same pattern as your main container)
  image: "fluent/fluent-bit"
  
  # Version (tag) of the Fluent Bit image
  version: "2.2"

  # Always | IfNotPresent | Never
  imagePullPolicy: Always 

  imagePullSecrets:
    # Set to true if Fluent Bit should use a private registry pull secret
    enabled: false
    data:
      # Docker registry username for Fluent Bit image
      username: myuser
      # Docker registry password or personal access token
      password: teste
      # Email address associated with the Docker registry account
      email: myuser@example.com
      # Docker registry URL
      registry: https://index.docker.io/v1/
  
  # Resource requests and limits for the container
  resources:
    # Minimum guaranteed CPU and memory for the container
    requests:
      cpu: "500m"
      memory: "512Mi"
    # Maximum CPU and memory the container can consume
    limits:
      cpu: "1"
      memory: "1Gi"

  # Config files stored as strings in values.yaml
  config:
    main: |
      [SERVICE]
          Flush        2
          Daemon       Off
          Log_Level    info
          Parsers_File /fluent-bit/etc/parsers.conf

      [INPUT]
          Name              tail
          Path              /opt/intel/pccs/logs/*.log
          Read_from_Head    Off
          Tag               pccs.*
          Parser            pccs_service_log

      # EXCLUDE Client Request-ID lines
      [FILTER]
          Name          grep
          Match         pccs.*
          Exclude       log Client Request-ID.*

      # Parse HTTP logs - this will only process the remaining lines
      [FILTER]
          Name          parser
          Match         pccs.*
          Key_Name      log
          Parser        pccs_http_log
          Reserve_Data  On

      [FILTER]
          Name        record_modifier
          Match       pccs.*
          Record      job pccs

      [OUTPUT]
          Name        loki
          Match       pccs.*
          Host        loki-gateway.monitoring.svc.cluster.local
          Port        80
          Labels      job=pccs, log_level=$log_level, status=$status, method=$method, path=$path
          Line_Format key_value

    parsers: |
      [PARSER]
          Name        pccs_service_log
          Format      regex
          Regex       ^(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\s\[(?<log_level>[a-zA-Z]+)\]:\s(?<message>.*)
          Time_Key    time
          Time_Format %Y-%m-%d %H:%M:%S.%L

      [PARSER]
          Name        pccs_http_log
          Format      regex
          Regex       ^(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\s\[(?<log_level>[a-zA-Z]+)\]:\s(?<remote_addr>[0-9.]+)\s-\s-\s\[(?<http_time>[0-9\/: +]+)\]\s"(?<method>[A-Z]+)\s(?<path>[^ ]+)\sHTTP\/(?<http_version>[0-9.]+)"\s(?<status>[0-9]+)\s(?<bytes_sent>[0-9]+)\s"(?<referrer>[^"]*)"\s"(?<user_agent>[^"]*)"
          Time_Key    time
          Time_Format %Y-%m-%d %H:%M:%S.%L

# Configuration for exposing the application externally via Ingress
ingress:

  # Enables or disables Ingress resource creation
  enabled: true

  # The fully-qualified domain name that routes traffic to this service.
  # Replace with your actual domain name.
  host: "pccs.example.com"

  # The name of the IngressClass to use for this Ingress resource.
  # This must match the name of an existing IngressClass in the cluster.
  # Common values include "nginx", "traefik", or custom names depending on the controller.
  className: nginx

  # The name of the Kubernetes TLS secret that stores the certificate and private key.
  # This secret is used to enable HTTPS for the specified host in the Ingress.
  # It can be manually created or automatically managed via cert-manager.
  tlsSecretName: ingress-tls

  # List of URL paths to be routed to this application by the ingress controller.
  # These paths should match the API endpoints you want exposed externally.
  paths:
    # SGX certification API
    - "/sgx/"

    # TDX certification API (v4)
    - "/tdx/"

    # Health probes
    - /health/

  # Enables backend TLS verification (mutual TLS verification with the backend service)
  nginx:
    backendVerification: true

  # Optional: Additional annotations
  annotations: {}

# Certificate Manager configuration (requires cert-manager to be installed in the cluster)
certManager:

  # Enables automatic TLS certificate management via cert-manager
  enabled: true

  # Configuration for the ACME certificate issuer
  issuer:

    # The name used to identify this cert-manager Issuer or ClusterIssuer
    name: "pccs-issuer"

    # The type of issuer to create. Supported values:
    # - "acme": Use ACME protocol (e.g., Let's Encrypt) to obtain certificates.
    # - "selfSigned": Create a self-signed issuer for local or testing use.
    type: selfSigned

    # URL of the ACME server to use for issuing certificates (only used if type is "acme").
    # Use Let's Encrypt staging URL for testing:
    #   https://acme-staging-v02.api.letsencrypt.org/directory
    # Use Let's Encrypt production URL for live certificates:
    #   https://acme-v02.api.letsencrypt.org/directory
    server: "https://acme-staging-v02.api.letsencrypt.org/directory"

    # Contact email address for certificate expiration notices and ACME registration
    # (only used if type is "acme").
    email: "example@mymail.com"

# Persistent Volume Claim (PVC) Configuration
persistentVolumeClaim:

  db:
     # Volume size (e.g., 5Gi, 500Mi)
    size: "512Mi"

    # Storage class for PVC (e.g., "standard", "default")
    storageClassName: "default"

    # Access modes options: ReadWriteOnce, ReadOnlyMany and ReadWriteMany
    accessModes:
      - ReadWriteOnce

  logs:
    # Volume size (e.g., 5Gi, 500Mi)
    size: "512Mi"

    # Storage class for PVC (e.g., "standard", "default")
    storageClassName: "default"

    # Access modes options: ReadWriteOnce, ReadOnlyMany and ReadWriteMany
    accessModes:
      - ReadWriteOnce

pccsConfig:
  # The hosts that will be accepted for connections. Default is localhost only. To accept all connections use 0.0.0.0
  hosts: "0.0.0.0"

  # The port used by the service inside the container. Default is 8081
  httpsPort: 8081

  # The URL of Intel Provisioning Certificate Service. The default URL is https://api.trustedservices.intel.com/sgx/certification/v4/
  uri: "https://api.trustedservices.intel.com/sgx/certification/v4/"

  # The PCCS uses this API key (DCAP) to request collaterals from Intel's Provisioning Certificate Service.
  # User needs to subscribe first to obtain an API key. For how to subscribe to Intel Provisioning Certificate
  # Service and receive an API key, goto https://api.portal.trustedservices.intel.com/provisioning-certification
  # and click on 'Subscribe'.
  apiKey: ""

  # Specify the proxy server for internet connection, for example, "http://192.168.1.1:80". Leave blank for no proxy or system proxy.
  proxy: ""

  # cron-style refresh schedule for the PCCS to refresh cached artifacts including CRL/TCB Info/QE Identity/QVE Identity. The default
  #setting is "0 0 1 * * *", which means refresh at 1:00 AM every day. Check https://docs.gitlab.com/topics/cron/ for more examples
  refreshSchedule: "0 0 1 * * *"

  # Sha512 hash of the user token for the PCCS client user to register a platform. For example, PCK Cert ID retrieval tool will
  # use the user token to send platform information to PCCS.
  # The value below is an example.
  userTokenHash: "6ae2d3bfb3b95517b358fcdb29f7743246101ebf13f797d8244df795eec2d1d769a41c059dc37beadac8e40cecab4352764336a90302920ddeb1a6c6df4e8a00"

  # Sha512 hash of the administrator token for the PCCS administrator to perform a manual refresh of cached artifacts.
  # The value below is an example.
  adminTokenHash: "31a556961f3438f9f632ca27812d22228e98e5083eea2bf9b78d0bb374d44deb0dc4d1bc16ab64127eb74e8452ea6902d97937c28310a7ab62a9ae1c15d96d69"

  # Caching mode options: LAZY, OFFLINE, or REQ
  # https://github.com/intel/SGXDataCenterAttestationPrimitives/tree/dcap_1.21_reproducible/QuoteGeneration/pccs#caching-fill-mode
  cachingFillMode: "LAZY"

  # OpenSSL FIPS mode (set `true` to enforce FIPS 140-2 compliance)
  opensslFipsMode: false

  # Log level. Use the same levels as npm: error, warn, info, http, verbose, debug, silly. Default is info.
  logLevel: "info"

  storage:
    # Database type: use "sqlite" or "mysql"
    dialect: "sqlite"

    # Database connection settings
    database: "pckcache"
    username: "username"
    password: "password"
    host: "localhost"

    # MySQL-specific settings (ignored for SQLite)
    port: 3306

    # Connection pool configuration
    pool:
      max: 5          # Maximum number of connections
      min: 0          # Minimum number of connections
      acquire: 30000  # Max time (ms) to try acquiring a connection before throwing an error
      idle: 10000     # Max time (ms) a connection can remain idle before being released

    # Ensure Sequelize uses table names as defined in models
    freezeTableName: true

    # Enable or disable SQL query logging (set to `true` for debugging)
    logging: false

    # SQLite storage file (ignored for MySQL)
    filename: "pckcache.db"

    # MySQL SSL settings (only required if connecting over SSL)
    ssl:
      required: true
      ca: "/if_required/path/to/your_ssl_ca"
