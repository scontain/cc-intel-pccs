image: "ghcr.io/opensovereigncloud/sgxdatacenterattestationprimitives/pccs"
version: "v1.23"
replicas: 3

imagePullSecrets:
  # Set to true to create an image pull secret automatically
  # using the credentials provided below.
  enabled: false
  data:
    # Docker registry username
    username: raisson
    # Docker registry password or personal access token
    password: teste
    # Email associated with the Docker registry account
    email: myuser@example.com
    # Docker registry URL
    registry: https://index.docker.io/v1/

# pod-level security settings to minimize security risks
podSecurityContext:
  # We run the container using the same user defined in the image.
  runAsUser: 65333
  fsGroup: 65333
  runAsNonRoot: true

# Topology Spread Constraints allow pods to be distributed across failure domains
# to improve resilience and high availability.
topologySpreadConstraints:
  # Enable or disable the application of topology spread constraints.
  enabled: true
  # The maximum skew allowed between the number of pods in different topology domains.
  maxSkew: 1
  # The topology key to use for spreading pods, e.g., zone, node, or hostname.
  topologyKey: "topology.kubernetes.io/zone"
  # What to do if the constraint cannot be satisfied:
  # "ScheduleAnyway" (soft) or "DoNotSchedule" (hard).
  whenUnsatisfiable: "ScheduleAnyway"

# Startup probe checks if the application has successfully started
# Paths appear to vary based on the selected configuration (e.g., using v3 updates all paths accordingly).
# Making probe endpoints configurable would allow adjustments if they change due to configuration changes.
startupProbe:
  enabled: true
  path: "/sgx/certification/v4/rootcacrl"

# Liveness probe ensures the application is still running and responsive
livenessProbe:
  enabled: true
  path: "/sgx/certification/v4/rootcacrl"

# Readiness probe ensures the service is ready to accept traffic
readinessProbe:
  enabled: true
  path: "/sgx/certification/v4/rootcacrl"

# PCCS Kubernetes service configuration
service:
  port: 8081

# Configuration for exposing the application externally via Ingress
ingress:

  # Enables or disables Ingress resource creation
  enabled: true

  # The fully-qualified domain name that routes traffic to this service.
  # Replace with your actual domain name.
  host: "pccs.example.com"

  # The name of the IngressClass to use for this Ingress resource.
  # This must match the name of an existing IngressClass in the cluster.
  # Common values include "nginx", "traefik", or custom names depending on the controller.
  className: nginx

  # The name of the Kubernetes TLS secret that stores the certificate and private key.
  # This secret is used to enable HTTPS for the specified host in the Ingress.
  # It can be manually created or automatically managed via cert-manager.
  tlsSecretName: ingress-tls

  # List of URL paths to be routed to this application by the ingress controller.
  # These paths should match the API endpoints you want exposed externally.
  paths:
    # SGX certification API (v3)
    - "/sgx/certification/v3"

    # SGX certification API (v4)
    - "/sgx/certification/v4"

    # TDX certification API (v4)
    - "/tdx/certification/v4"

  # Enables backend TLS verification (mutual TLS verification with the backend service)
  nginx:
    backendVerification: true

  # Optional: Additional annotations
  annotations: {}

# Certificate Manager configuration (requires cert-manager to be installed in the cluster)
certManager:

  # Enables automatic TLS certificate management via cert-manager
  enabled: true

  # Configuration for the ACME certificate issuer
  issuer:

    # The name used to identify this cert-manager Issuer or ClusterIssuer
    name: "pccs-issuer"

    # The type of issuer to create. Supported values:
    # - "acme": Use ACME protocol (e.g., Let's Encrypt) to obtain certificates.
    # - "selfSigned": Create a self-signed issuer for local or testing use.
    type: selfSigned

    # URL of the ACME server to use for issuing certificates (only used if type is "acme").
    # Use Let's Encrypt staging URL for testing:
    #   https://acme-staging-v02.api.letsencrypt.org/directory
    # Use Let's Encrypt production URL for live certificates:
    #   https://acme-v02.api.letsencrypt.org/directory
    server: "https://acme-staging-v02.api.letsencrypt.org/directory"

    # Contact email address for certificate expiration notices and ACME registration
    # (only used if type is "acme").
    email: "example@mymail.com"

# Persistent Volume Claim (PVC) Configuration
persistentVolumeClaim:

  db:
     # Volume size (e.g., 5Gi, 500Mi)
    size: "512Mi"

    # Storage class for PVC (e.g., "standard", "default")
    storageClassName: "default"

    # Access modes options: ReadWriteOnce, ReadOnlyMany and ReadWriteMany
    accessModes:
      - ReadWriteOnce

  logs:
    # Volume size (e.g., 5Gi, 500Mi)
    size: "512Mi"

    # Storage class for PVC (e.g., "standard", "default")
    storageClassName: "default"

    # Access modes options: ReadWriteOnce, ReadOnlyMany and ReadWriteMany
    accessModes:
      - ReadWriteOnce

pccsConfig:
  # The hosts that will be accepted for connections. Default is localhost only. To accept all connections use 0.0.0.0
  hosts: "0.0.0.0"

  # The port used by the service inside the container. Default is 8081
  httpsPort: 8081

  # The URL of Intel Provisioning Certificate Service. The default URL is https://api.trustedservices.intel.com/sgx/certification/v4/
  uri: "https://api.trustedservices.intel.com/sgx/certification/v4/"

  # The PCCS uses this API key to request collaterals from Intel's Provisioning Certificate Service.
  # User needs to subscribe first to obtain an API key. For how to subscribe to Intel Provisioning Certificate
  # Service and receive an API key, goto https://api.portal.trustedservices.intel.com/provisioning-certification
  # and click on 'Subscribe'.
  apiKey: ""

  # Specify the proxy server for internet connection, for example, "http://192.168.1.1:80". Leave blank for no proxy or system proxy.
  proxy: ""

  # cron-style refresh schedule for the PCCS to refresh cached artifacts including CRL/TCB Info/QE Identity/QVE Identity. The default
  #setting is "0 0 1 * * *", which means refresh at 1:00 AM every day. Check https://docs.gitlab.com/topics/cron/ for more examples
  refreshSchedule: "0 0 1 * * *"

  # Sha512 hash of the user token for the PCCS client user to register a platform. For example, PCK Cert ID retrieval tool will
  # use the user token to send platform information to PCCS.
  # The value below is an example.
  userTokenHash: "6ae2d3bfb3b95517b358fcdb29f7743246101ebf13f797d8244df795eec2d1d769a41c059dc37beadac8e40cecab4352764336a90302920ddeb1a6c6df4e8a00"

  # Sha512 hash of the administrator token for the PCCS administrator to perform a manual refresh of cached artifacts.
  # The value below is an example.
  adminTokenHash: "31a556961f3438f9f632ca27812d22228e98e5083eea2bf9b78d0bb374d44deb0dc4d1bc16ab64127eb74e8452ea6902d97937c28310a7ab62a9ae1c15d96d69"

  # Caching mode options: LAZY, OFFLINE, or REQ
  # https://github.com/intel/SGXDataCenterAttestationPrimitives/tree/dcap_1.21_reproducible/QuoteGeneration/pccs#caching-fill-mode
  cachingFillMode: "LAZY"

  # OpenSSL FIPS mode (set `true` to enforce FIPS 140-2 compliance)
  opensslFipsMode: false

  # Log level. Use the same levels as npm: error, warn, info, http, verbose, debug, silly. Default is info.
  logLevel: "info"

  storage:
    # Database type: use "sqlite" or "mysql"
    dialect: "sqlite"

    # Database connection settings
    database: "pckcache"
    username: "username"
    password: "password"
    host: "localhost"

    # MySQL-specific settings (ignored for SQLite)
    port: 3306

    # Connection pool configuration
    pool:
      max: 5          # Maximum number of connections
      min: 0          # Minimum number of connections
      acquire: 30000  # Max time (ms) to try acquiring a connection before throwing an error
      idle: 10000     # Max time (ms) a connection can remain idle before being released

    # Ensure Sequelize uses table names as defined in models
    freezeTableName: true

    # Enable or disable SQL query logging (set to `true` for debugging)
    logging: false

    # SQLite storage file (ignored for MySQL)
    filename: "pckcache.db"

    # MySQL SSL settings (only required if connecting over SSL)
    ssl:
      required: true
      ca: "/if_required/path/to/your_ssl_ca"
